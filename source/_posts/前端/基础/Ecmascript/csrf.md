---
title: CSRF
toc: true
date: 2017-11-25  10:35:12
tags: [前端,CSRF,JS基础]
---


# CSRF简介

`Cross Site Request Forgery, 跨站域请求伪造`

```

假设abc用户登录银行的网站进行操作, 同时也访问了攻击者预先设置好的网站.
abc点击了攻击者网站的某一个链接,这个链接是http://www.bank.com/xxxx指向银行,银行服务器会根据这个链接携带的参数会进行转账操作.
银行服务器在执行转账操作之前会进行SESSION验证是否登录, 但是由于abc已经登录了银行网站,攻击者的链接也是www.bank.com.所以攻击的链接就会携带session id到银行服务器.
由于session id是正确的,所以银行会判断操作是由本人发起的,执行转账操作.

```

要完成一次CSRF攻击，受害者必须一次完成两个步骤

1.登陆受信任网站A，并在本地生成cookie
2.在不退出A的情况下，访问了危险网站B

到这里，你也许会说：如果我不满足以上条件的中的任何一个，就不会受到攻击。但是你不能保证以下条件不会发生：

1. 你不能保证你登陆了一个网站后，不再打开一个tab 页面并访问另外的网站。
2. 你不能保证你关闭浏览器后，你本地的cookie 马上过期，你上次的会话已经结束
3. 存在其他漏洞的可信任的经常被人访问的网站。

# 防止csrf的几种方法


## 服务器端进行CSRF防御


1. Cookie Hashing(所有表单都包含同一个伪随机值)：

>可以在表单中嵌入一个随机的token。当真正的用户提交表单的时，你就会收到表单的随机 token，这样你就可以通过之前嵌入的那个随机 token 来校验了。在 CSRF 攻击场景中，攻击者永远都不可能拿到这个值甚至在攻击者可以请求到页面的情况也无法拿到，因为同源策略（SOP）会阻止攻击者从包含 token 的响应中读取内容。这个方法在实际运用中很不错，但是它需要网站追踪每一个请求并且返回 Anti-CSRF tokens。还有一个类似的在表单中嵌入 token 的方法是给浏览器一个包含相同值的 cookie 来实现的。当网站收到真正的用户提交他们的表单时，cookie 中的值和表单中的值将会相匹配。攻击者通过没有 CSRF cookie 的浏览器发送伪造的请求将会失败。


2. One-Time Tokens(不同的表单包含一个不同的伪随机值):

  >如果用户在一个站点上同时打开了两个不同的表单，CSRF保护措施不应该影响到他对任何表单的提交。考虑一下如果每次表单被装入时站点生成一个伪随机值来覆盖以前的伪随机值将会发生什么情况：用户只能成功地提交他最后打开的表单，因为所有其他的表单都含有非法的伪随机值。必须小心操作以确保CSRF保护措施不会影响选项卡式的浏览或者利用多个浏览器窗口浏览一个站点。
 
 >令牌同步模式（Synchronizer token pattern，简称STP）是在用户请求的页面中的所有表单中嵌入一个token，在服务端验证这个token的技术。token可以是任意的内容，但是一定要保证无法被攻击者猜测到或者查询到。攻击者在请求中无法使用正确的token，因此可以判断出未授权的请求。


# 验证了origin和refer是否能完全避免?

> 根据HTTP协议,在http请求头中包含一个referer的字段,这个字段记录了该http请求的原地址.通常情况下,执行转账操作的post请求www.bank.com/transfer.php应该是点击www.bank.com网页的按钮来触发的操作,这个时候转账请求的referer应该是www.bank.com.而如果黑客要进行csrf攻击,只能在自己的网站www.hacker.com上伪造请求.伪造请求的referer是www.hacker.com.所以我们通过对比post请求的referer是不是www.bank.com就可以判断请求是否合法.

`黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。`

>为了防止CSRF的攻击，可以浏览器在发送POST请求的时候加上一个Origin字段，这个Origin字段主要是用来标识出最初请求是从哪里发起的。如果浏览器不能确定源在哪里，那么在发送的请求里面Origin字段的值就为空。

`如果攻击者如果直接通过假页面提交Form，则不能在header里设置X-From属性；而如果攻击者也用Ajax提交，则header里的Origin因为不能伪造，也不能达到攻击的目的。从而达到了预防CSRF的目的。`


